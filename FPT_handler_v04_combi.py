# -*- coding: utf-8 -*-
"""Subclass of FPT_MainWin, which is generated by wxFormBuilder."""

import wx
import FPT_combi


import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
#from numpy import sin,cos,tan,pi,sqrt,arctan
from matplotlib.backends.backend_wxagg import \
        FigureCanvasWxAgg as FigCanvas, \
        NavigationToolbar2WxAgg as Toolbar
        
#поддержка кариллицы
font = {'family': 'Arial', 'weight': 'normal', 'size':12}
mpl.rc('font', **font)

# Implementing FPT_MainWin
class FPT_handler_combi( FPT_combi.FPT_MainWin ):
    def __init__( self, parent ):
        FPT_combi.FPT_MainWin.__init__( self, parent )
        self.AllOK = False
        self.winplot_exists=False
        
    def __del__( self ):
        self.data=None
        self.amp=None
        self.fgr1=None
        
	
	# Handlers for FPT_MainWin events.
    def OnFileOpen( self, event ):
        self.filename = self.m_filePicker.GetPath()
        self.name_of_file = '.'.join(self.filename.split('\\')[-1].split('.')[0:-1])
        print 'File chosen'
        self.AllOK = False
	
    def OnImportPress( self, event ):
        rows_to_skip = int(self.m_rowstoskip.GetValue())
        il_col_no = int(self.m_il_col.GetValue())-1
        xl_col_no = int(self.m_xl_col.GetValue())-1
        data_col_no = int(self.m_data_col.GetValue())-1
        
        self.t_imp_status.SetLabel(u'Importing...')
        
        try:
            self.data = pd.read_csv(self.filename,
                   skiprows=rows_to_skip, delim_whitespace=True,header=None)
    
            self.il=self.data.iloc[:,il_col_no].values.astype(int)
            self.xl=self.data.iloc[:,xl_col_no].values.astype(int)
            self.amp=self.data.iloc[:,data_col_no].values
            self.mean_amp_value=np.mean(self.amp)

            
            
        except Exception:
            self.t_imp_status.SetLabel(u'Cannot import :(')
            self.AllOK = False
            print 'Aborted import.'
        
        else:
  
            self.m_text_il_max.SetValue(str(np.max(self.il).astype(int)))
            self.m_text_il_min.SetValue(str(np.min(self.il).astype(int)))
            self.m_text_xl_max.SetValue(str(np.max(self.xl).astype(int)))
            self.m_text_xl_min.SetValue(str(np.min(self.xl).astype(int)))
            
                      
            if not self.m_text_il_xl_aspect.GetValue(): 
                self.m_text_il_xl_aspect.SetValue(str(1))

            
            
            self.t_imp_status.SetLabel(u'Success!')
            self.AllOK = True
            print 'Imported file {0} successfully'.format(self.name_of_file)
    
	
    def OnPlotBtn( self, event ):
        print 'Plot Button Pressed'
        if not (self.AllOK):
            print 'Not ready to plot yet.'
            return
            self.t_plot_status.SetLabel(u'Not ready to plot yet :(')
	
        self.t_plot_status.SetLabel(u'Computations started')
        self.Update()
#      get only necessary data
        ilmin=int(self.m_text_il_min.GetValue())
        ilmax=int(self.m_text_il_max.GetValue())
        xlmin=int(self.m_text_xl_min.GetValue())
        xlmax=int(self.m_text_xl_max.GetValue())
        self.il_reverse = bool(self.m_checkBox_IL_rev.GetValue())
        self.xl_reverse = bool(self.m_checkBox_XL_rev.GetValue())
        
        
        ind_to_plot=((self.xl>=xlmin) & (self.il>=ilmin) & (self.xl<=xlmax) & (self.il<=ilmax))
                     
        
        il=self.il[ind_to_plot]
        xl=self.xl[ind_to_plot]
        amp=self.amp[ind_to_plot]
        
        
        slice_stats={'ilmin': np.min(il), 'xlmin': np.min(xl), 
                     'xlmax': np.max(xl), 'ilmax': np.max(il),
                     'dil': 1, 'dxl': 1,
                     'nil':((np.max(il)-np.min(il))/1+1).astype(int),'nxl':((np.max(xl)-np.min(xl))/1+1).astype(int),
                      'aspect_ratio': float(self.m_text_il_xl_aspect.GetValue()) }
        
        self.amp_stats={'min': np.min(amp), 'max': np.max(amp), 'avg': np.mean(amp), 'rms':np.std(amp)}
        amp=amp-self.mean_amp_value

        datamat = self.AG_matrix_from_xyz(il, xl, amp, slice_stats)
        empty_points=np.isnan(datamat)
        datamat[empty_points]=0
        
        
#        datamat=datamat-self.mean_amp_value
        
        
        
        ilmat = np.linspace(slice_stats['ilmin'], slice_stats['ilmax'], slice_stats['nil'])
        xlmat = np.linspace(slice_stats['xlmin'], slice_stats['xlmax'], slice_stats['nxl'])

                
        ind_mid_il=np.floor(slice_stats['nil']/2).astype(int)
        ind_mid_xl=np.floor(slice_stats['nxl']/2).astype(int)
        
        self.t_plot_status.SetLabel(u'indexing complete. Starting FFT')
        self.Update()
        
        W_orig=np.fft.fft2(datamat)
        W=np.fft.fftshift(W_orig)
        S=abs(W)
        P=np.angle(W)
        
        self.t_plot_status.SetLabel(u'FFT complete')
        self.Update()

        damp_f = np.ones_like(S)
        pres_f = np.ones_like(S)
        
        
        
        
        
        
#   Set Gaussian Parameeres
        
        if not self.m_textGauIL.GetValue(): 
#            est_f_il = np.floor(ind_mid_il/3).astype(int)
            est_f_il = 0
            self.m_textGauIL.SetValue(str(est_f_il))
            print 'No GauIL specified, autoset: '+str(est_f_il)
        else:
            est_f_il = float(self.m_textGauIL.GetValue())
        
        if not self.m_textGauXL.GetValue():  #check whether field is empty
#            est_f_xl=np.floor(ind_mid_xl/3).astype(int)
            est_f_xl=0
            self.m_textGauXL.SetValue(str(est_f_xl))
            print 'No GauXL specified, autoset: '+str(est_f_xl)
        else:
            est_f_xl = float(self.m_textGauXL.GetValue())
        
                
        if not self.m_textGauILSize.GetValue():  #check whether field is empty
            stdil=np.floor(0.005*slice_stats['nxl']).astype(int)
            self.m_textGauILSize.SetValue(str(stdil))
            print 'No size Il specified, autoset: '+str(stdil)
        else:
            stdil = float(self.m_textGauILSize.GetValue())
        
        if not self.m_textGauXLSize.GetValue():  #check whether field is empty
            stdxl=np.floor(0.005*slice_stats['nil']).astype(int)
            self.m_textGauXLSize.SetValue(str(stdxl))
            print 'No SizeXl specified, autoset: '+str(stdxl)
        else:
            stdxl = float(self.m_textGauXLSize.GetValue())
            
            
        if not self.m_textGauILWid.GetValue():  #check whether field is empty
            wid_il=np.floor(slice_stats['nil']).astype(int)
            self.m_textGauILWid.SetValue(str(wid_il))
            print 'No size Il specified, autoset: '+str(wid_il)
        else:
            wid_il = float(self.m_textGauILWid.GetValue())
        
        if not self.m_textGauXLWid.GetValue():  #check whether field is empty
            wid_xl=np.floor(slice_stats['nxl']).astype(int)
            self.m_textGauXLWid.SetValue(str(wid_xl))
            print 'No SizeXl specified, autoset: '+str(wid_xl)
        else:
            wid_xl = float(self.m_textGauXLWid.GetValue())
            
        if not self.m_textGauIL_kdamp.GetValue():  #check whether field is empty
            kdamp_il=1000
            self.m_textGauIL_kdamp.SetValue(str(kdamp_il))
            print 'No size Il specified, autoset: '+str(kdamp_il)
        else:
            kdamp_il = float(self.m_textGauIL_kdamp.GetValue())
        
        if not self.m_textGauXL_kdamp.GetValue():  #check whether field is empty
            kdamp_xl=1000
            self.m_textGauXL_kdamp.SetValue(str(kdamp_xl))
            print 'No SizeXl specified, autoset: '+str(kdamp_xl)
        else:
            kdamp_xl = float(self.m_textGauXL_kdamp.GetValue())        
        
        
        
        
        
        
#   Set Radial Notch Parameeres
        
        if not self.m_text_rad1IL.GetValue(): 
#            est_f_il = np.floor(ind_mid_il/3).astype(int)
            rad1_il = np.floor(ind_mid_il/2).astype(int)
            self.m_text_rad1IL.SetValue(str(rad1_il))
            print 'No Rad1Il specified, autoset: '+str(rad1_il)
        else:
            rad1_il = float(self.m_text_rad1IL.GetValue())
        
        if not self.m_text_rad1XL.GetValue():  #check whether field is empty
#            est_f_xl=np.floor(ind_mid_xl/3).astype(int)
            rad1_xl= np.floor(ind_mid_xl/2).astype(int)
            self.m_text_rad1XL.SetValue(str(rad1_xl))
            print 'No Rad1Xl specified, autoset: '+str(rad1_xl)
        else:
            rad1_xl = float(self.m_text_rad1XL.GetValue())
            
        if not self.m_text_rad2IL.GetValue(): 
#            est_f_il = np.floor(ind_mid_il/3).astype(int)
            rad2_il = np.floor(ind_mid_il/2).astype(int)
            self.m_text_rad2IL.SetValue(str(rad2_il))
            print 'No Rad2Il specified, autoset: '+str(rad2_il)
        else:
            rad2_il = float(self.m_text_rad2IL.GetValue())
        
        if not self.m_text_rad2XL.GetValue():  #check whether field is empty
#            est_f_xl=np.floor(ind_mid_xl/3).astype(int)
            rad2_xl= np.floor(ind_mid_xl/2).astype(int)
            self.m_text_rad2XL.SetValue(str(rad2_xl))
            print 'No Rad2Xl specified, autoset: '+str(rad2_xl)
        else:
            rad2_xl = float(self.m_text_rad2XL.GetValue())
        
        
        if not self.m_text_Rad1Size.GetValue():  #check whether field is empty
#            est_f_xl=np.floor(ind_mid_xl/3).astype(int)
            rad1_Size= 20
            self.m_text_Rad1Size.SetValue(str(rad1_Size))
            print 'No Rad1Size specified, autoset: '+str(rad1_Size)
        else:
            rad1_Size = float(self.m_text_Rad1Size.GetValue())

                
        if not self.m_text_Rad2Size.GetValue(): 
#            est_f_il = np.floor(ind_mid_il/3).astype(int)
            rad2_Size = 20
            self.m_text_Rad2Size.SetValue(str(rad2_Size))
            print 'No Rad2Size specified, autoset: '+str(rad2_Size)
        else:
            rad2_Size = float(self.m_text_Rad2Size.GetValue())

            
            
        if not self.m_text_Rad1Asp.GetValue():  #check whether field is empty
#            est_f_xl=np.floor(ind_mid_xl/3).astype(int)
            rad1_Asp= 1
            self.m_text_Rad1Asp.SetValue(str(rad1_Asp))
            print 'No Rad1Asp specified, autoset: '+str(rad1_Asp)
        else:
            rad1_Asp = float(self.m_text_Rad1Asp.GetValue())

                
        if not self.m_text_Rad2Asp.GetValue(): 
#            est_f_il = np.floor(ind_mid_il/3).astype(int)
            rad2_Asp = 1
            self.m_text_Rad2Asp.SetValue(str(rad2_Asp))
            print 'No Rad2Asp specified, autoset: '+str(rad2_Asp)
        else:
            rad2_Asp = float(self.m_text_Rad2Asp.GetValue())
            
        if not self.m_text_Rad1kdamp.GetValue():  #check whether field is empty
#            est_f_xl=np.floor(ind_mid_xl/3).astype(int)
            rad1_kdamp= 1.000
            self.m_text_Rad1kdamp.SetValue(str(rad1_kdamp))
            print 'No Rad1kdamp specified, autoset: '+str(rad1_kdamp)
        else:
            rad1_kdamp = float(self.m_text_Rad1kdamp.GetValue())

                
        if not self.m_text_Rad2kdamp.GetValue(): 
#            est_f_il = np.floor(ind_mid_il/3).astype(int)
            rad2_kdamp = 1.000
            self.m_text_Rad2kdamp.SetValue(str(rad2_kdamp))
            print 'No Rad2kdamp specified, autoset: '+str(rad2_kdamp)
        else:
            rad2_kdamp = float(self.m_text_Rad2kdamp.GetValue())
            
            
            
            
            
            
        
        self.t_plot_status.SetLabel(u'Parameters set')
        self.Update()
        
        
#        self.m_textGauIL.SetValue(str(est_f_il))
#        self.m_textGauXL.SetValue(str(est_f_xl))
#        self.m_textGauILSize.SetValue(str(stdil))
#        self.m_textGauXLSize.SetValue(str(stdxl))
#        self.m_textGauILAsp.SetValue(str(aspect_gauss_il))
#        self.m_textGauXLAsp.SetValue(str(aspect_gauss_xl))
#        self.m_textGauIL_kdamp.SetValue(str(kdamp_il))
#        self.m_textGauXL_kdamp.SetValue(str(kdamp_xl))
        
        
        if bool(self.m_checkBox_rad_notch.GetValue()):

            damp_f = damp_f + rad1_kdamp*(1 - self.AG_smoothstep2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'], rad1_il, rad1_xl,  rad1_Size, rad1_Asp, rad1_Size/10))
            damp_f = damp_f + rad1_kdamp*(1 - self.AG_smoothstep2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'], slice_stats['nil']-rad1_il, slice_stats['nxl']-rad1_xl, rad1_Size, rad1_Asp, rad1_Size/10) )
            damp_f = damp_f + rad2_kdamp*(1 - self.AG_smoothstep2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'], rad2_il, rad2_xl,  rad2_Size, rad2_Asp, rad2_Size/10))
            damp_f = damp_f + rad2_kdamp*(1 - self.AG_smoothstep2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'], slice_stats['nil']-rad2_il, slice_stats['nxl']-rad2_xl, rad2_Size, rad2_Asp, rad2_Size/10))
            
            print 'RadNotch: Success!'
        
        if bool(self.m_checkBox_gau1.GetValue()):
            damp_f=damp_f+kdamp_il*self.AG_gauss2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'], slice_stats['nil']-est_f_il, ind_mid_xl, wid_il/3, stdil/3 )
            damp_f=damp_f+kdamp_il*self.AG_gauss2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'], est_f_il, ind_mid_xl, wid_il/3, stdil/3 )
            damp_f=damp_f+kdamp_xl*self.AG_gauss2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'], ind_mid_il, est_f_xl,  stdxl/3, wid_xl/3)
            damp_f=damp_f+kdamp_xl*self.AG_gauss2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'], ind_mid_il, slice_stats['nxl']-est_f_xl, stdxl/3, wid_xl/3 )
            print 'Gaussian filter: Success!'


        
#   Set Radial Parameeres
        
        if not self.m_textRad_rad.GetValue():  #check whether field is empty
            radius=np.floor(slice_stats['nil']*0.01).astype(int)
            self.m_textRad_rad.SetValue(str(radius))
            print 'No Radius specified, autoset: '+str(radius)
        else:
            radius= float(self.m_textRad_rad.GetValue()) 
        
        if not self.m_textRad_asp.GetValue():  #check whether field is empty
            rad_aspect=float(self.m_text_il_xl_aspect.GetValue())
            self.m_textRad_asp.SetValue(str(rad_aspect))
            print 'No RadialAspect specified, autoset: '+str(rad_aspect)
        else:
            rad_aspect = float(self.m_textRad_asp.GetValue()) 
                     
        if not self.m_textRad_sm.GetValue():  #check whether field is empty
            sm_factor=3
            self.m_textRad_sm.SetValue(str(sm_factor))
            print 'No SmFactor specified, autoset: '+str(sm_factor)
        else:
            sm_factor = float(self.m_textRad_sm.GetValue())  
         
#        if not self.m_textRad_kdamp.GetValue():  #check whether field is empty
#            rad_kdamp=20
#            self.m_textRad_kdamp.SetValue(str(rad_kdamp))
#            print 'No RadialKdamp specified, autoset: '+str(rad_kdamp)
#        else:
#            rad_kdamp = float(self.m_textRad_kdamp.GetValue())      
        
        
        if bool(self.m_checkBox_rad.GetValue()):
            pres_f=self.AG_smoothstep2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'],ind_mid_il,ind_mid_xl, radius, rad_aspect, sm_factor) 
#            print np.min(rad_kdamp*self.AG_smoothstep2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'],ind_mid_il,ind_mid_xl, radius, rad_aspect, sm_factor) )
#            print np.max(rad_kdamp*self.AG_smoothstep2d(ilmat-slice_stats['ilmin'], xlmat-slice_stats['xlmin'],ind_mid_il,ind_mid_xl, radius, rad_aspect, sm_factor) )
#            print np.min(damp_f)
#            print np.max(damp_f)
            print 'Radial filter: Success!'        

        self.t_plot_status.SetLabel(u'Filter applied')
        self.Update()
        
        Snew=S/damp_f
        Sout=Snew*(pres_f) + S*(1-pres_f)
        
        print 'Amp.Spectrum divided: Success!'
        Wout=Sout*np.exp(1j*P)
        print 'Amp&Phase multiplied'

        data_out=np.fft.ifft2(np.fft.ifftshift(Wout)) + self.mean_amp_value
        data_out[empty_points]=np.nan
        datamat[empty_points]=np.nan
        print 'Inverse 2D FFT: Success!'

        self.t_plot_status.SetLabel(u'Inverse 2D FFT: Success!')
        
        sp_rms = np.std(S)
        sp_mean = np.mean(S)
        
#for export        
        self.data_out=np.real(data_out)
        self.ilmat=ilmat
        self.xlmat=xlmat
        
        
#        if not self.winplot_exists:
        win_plot = FPT_combi.FramePlot(None)   
        print 'win_plot created'
        self.fgr1 = plt.Figure(facecolor='w')        
        print 'fgr1 created'
        win_plot.canvas = FigCanvas(win_plot.m_panel1, -1, self.fgr1)
        print 'canvas created'
        win_plot.toolbar = Toolbar(win_plot.canvas)        
        print 'toolbar created'
        plot_box = wx.BoxSizer(wx.VERTICAL)       
        print 'box created'
        plot_box.Add(win_plot.canvas, flag=wx.EXPAND,proportion=10)
        print 'canvas added'
        plot_box.Add(win_plot.toolbar, flag=wx.EXPAND)
        print 'toolbar added'
        win_plot.m_panel1.SetSizer(plot_box)
        print 'panel1 SizerSet'


        self.t_plot_status.SetLabel(u'Window ready to plot')
        self.Update()
        

        ax1 = self.fgr1.add_subplot(231)
        im1=ax1.imshow(datamat + self.mean_amp_value, origin='lower', interpolation='none', cmap='Spectral_r', 
                       vmin=-2*self.amp_stats['rms']+self.mean_amp_value,vmax=2*self.amp_stats['rms']+self.mean_amp_value,
                       extent=[slice_stats['xlmin'], slice_stats['xlmax'], slice_stats['ilmin'],slice_stats['ilmax']])
        print 'plot1 success'
        
        ax2 = self.fgr1.add_subplot(232, sharex=ax1, sharey=ax1)
        im2=ax2.imshow(np.real(data_out), origin='lower', interpolation='none', cmap='Spectral_r', 
                       vmin=-2*self.amp_stats['rms']+self.mean_amp_value,vmax=2*self.amp_stats['rms']+self.mean_amp_value,
                       extent=[slice_stats['xlmin'], slice_stats['xlmax'], slice_stats['ilmin'],slice_stats['ilmax']])
        print 'plot2 success'
        
        ax3 = self.fgr1.add_subplot(233, sharex=ax1, sharey=ax1)
        im3=ax3.imshow(np.real(data_out)-datamat, origin='lower', interpolation='none', cmap='Spectral_r', 
                       extent=[slice_stats['xlmin'], slice_stats['xlmax'], slice_stats['ilmin'],slice_stats['ilmax']])
        print 'plot3 success'
        


        ax4 = self.fgr1.add_subplot(234)
        ax4.imshow(S, aspect=slice_stats['aspect_ratio'], origin='lower', interpolation='none', cmap='Spectral_r',vmin = 0, vmax = sp_mean+4*sp_rms),

        print 'plot4 success'        
        
        
        ax5 = self.fgr1.add_subplot(235,sharex=ax4,sharey=ax4)
        ax5.imshow(Sout, aspect=slice_stats['aspect_ratio'], origin='lower', interpolation='none', cmap='Spectral_r',vmin = 0, vmax = sp_mean+4*sp_rms)
        print 'plot5 success'
        

        ax6 = self.fgr1.add_subplot(236,sharex=ax4,sharey=ax4)
        ax6.imshow(damp_f*pres_f + (1-pres_f)*np.ones_like(S), aspect=slice_stats['aspect_ratio'], origin='lower', interpolation='none', cmap='Spectral_r')
        print 'plot6 success'


        for axi in (ax1,ax2,ax3,ax4,ax5,ax6):
            axi.set_adjustable('box-forced')
            axi.set_aspect(slice_stats['aspect_ratio'])

        if (self.il_reverse):
            ax1.set_xlim(ax1.get_xlim()[::-1])
            ax2.set_xlim(ax2.get_xlim()[::-1])
            ax3.set_xlim(ax3.get_xlim()[::-1])        
        if (self.xl_reverse):
            ax1.set_ylim(ax1.get_ylim()[::-1])
            ax2.set_ylim(ax2.get_ylim()[::-1])
            ax3.set_ylim(ax3.get_ylim()[::-1])

        self.fgr1.tight_layout(pad=0.1)
        
        self.t_plot_status.SetLabel(u'Showing window...')

        win_plot.Show(True)         
        self.winplot_exists=True
        self.t_plot_status.SetLabel(u'Done')
 
#----==== My Functions =====---- 
    def AG_matrix_from_xyz(self,il, xl, amp, slice_stats):
        """returns a matrix from xyz data, IL in 0th dim, XL in 1st dim"""
        ilmin=slice_stats['ilmin']
        ilmax=slice_stats['ilmax']
        xlmin=slice_stats['xlmin']
        xlmax=slice_stats['xlmax']
        dil=slice_stats['dil']
        dxl=slice_stats['dxl']
        il_num=slice_stats['nil']
        xl_num=slice_stats['nxl']
        
        
        datamat=np.zeros((il_num,xl_num))*np.nan

                
        ind_il=((il-ilmin)/dil).astype(int)
        ind_xl=((xl-xlmin)/dxl).astype(int)
        
        for ipoint in xrange(len(il)):
            datamat[ ind_il[ipoint] , ind_xl[ipoint] ] = amp[ipoint]

            
        return datamat    


    def AG_xyz_from_matrix(self, ilmat, xlmat, data_out):
        """returns a matrix from xyz data, IL in 0th dim, XL in 1st dim"""
#        ilmin=slice_stats['ilmin']
#        ilmax=slice_stats['ilmax']
#        xlmin=slice_stats['xlmin']
#        xlmax=slice_stats['xlmax']
#        dil=slice_stats['dil']
#        dxl=slice_stats['dxl']
#        il_num=slice_stats['nil']
#        xl_num=slice_stats['nxl']
##       
        xlm,ilm=np.meshgrid(xlmat,ilmat)
        data_col= data_out.reshape(np.size(data_out),1)     
        ind_notnan= ~(np.isnan(data_col))
        array_to_sv=np.column_stack((ilm.reshape(np.size(ilm),1)[ind_notnan], xlm.reshape(np.size(xlm),1)[ind_notnan],data_col[ind_notnan] ))
#        self.output_data = self.output_data[not np.isnan(self.output_data[:,2]),: ]
#        for i, ili in enumerate(ilmat):
#            out_ij = np.real(data_out)[i,:]#[not np.isnan(np.real(data_out)[i,:])]
#            out[i*xl_num:(i+1)*xl_num,:] = np.column_stack(ili*np.ones(xl_num,1), xlmat., out_ij)
#            
#        out=out[not np.isnan(out[:,2])]      
          
#        ind_il=((il-ilmin)/dil).astype(int)
#        ind_xl=((xl-xlmin)/dxl).astype(int)
#        
#        for ipoint in xrange(len(il)):
#            datamat[ ind_il[ipoint] , ind_xl[ipoint] ] = amp[ipoint]

            
        return array_to_sv  



    def ExportClicked(self, event):
        if not (self.AllOK):
            print 'Not ready to export yet.'
            self.t_plot_status.SetLabel(u'Not ready to export yet :(')  
            self.Update()
            return
        # Save away the edited text
        # Open the file, do an RU sure check for an overwrite!
        self.output_data = self.AG_xyz_from_matrix(self.ilmat,self.xlmat,self.data_out)
        
        dlg = wx.FileDialog(self, "Choose a file", "", self.name_of_file+"_noFP.dat", "*.*", \
              wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
#        if dlg.ShowModal() == wx.ID_CANCEL:
#            return     # the user changed idea...
        if dlg.ShowModal() == wx.ID_OK:
            # Grab the content to be saved
            # Open the file for write, write, close
            self.outfilename = dlg.GetPath()
            np.savetxt(self.outfilename, self.output_data, delimiter=' ',header='',fmt=('%i','%i','%4.4f'))
            print 'Export '+self.name_of_file+"_noFP.dat"+' - Success!'
            self.t_plot_status.SetLabel(u'Export complete')
                    # Get rid of the dialog to keep things tidy
        dlg.Destroy()        
        
        



    def AG_smoothstep2d(self, x,y, centerx, centery, radius, rad_aspect, sm_factor):
        xm,ym = np.meshgrid(x,y)
        return 0.5-0.5*np.tanh((radius-np.sqrt(rad_aspect*(xm-centerx)**2 + (ym-centery)**2))/sm_factor).T
    
    def AG_gauss2d(self, x,y, mux, muy, sigx, sigy):
        xm,ym = np.meshgrid(x,y)
        return np.exp(-0.5*( (xm-mux)**2/sigx**2 + (ym-muy)**2/sigy**2) ).T
    
    
def main():
    app = wx.App()
    window = FPT_handler_combi(None)
        
    window.Show(True)
#    wx.lib.inspection.InspectionTool().Show()
    app.MainLoop()
        
if __name__ == "__main__":
    main() 